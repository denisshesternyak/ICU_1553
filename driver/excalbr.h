// Declarations for excalbr driver for Linux
// Based on Excalibur's Win2000 driver

#ifndef EXCALBR_H
#define EXCALBR_H

// General defines for the driver


#define EXC_DEVICE_NAME				L"\\Device\\Excalbr"
#define EXC_DOS_DEVICE_NAME			L"\\??\\ExcaliburDevice"
#define DRIVERNAME "EXCALBR"				// for use in messages
#define LDRIVERNAME L"EXCALBR"				// for use in UNICODE string constants

#include "exclinuxdef.h"
#include "excsysio.h"
//#include "excdebug.h"

// For Kernel 2.2, we declare a structure identical to the Linux pci_dev struct. 
// We declare the copy due to compile errors compiling the original
// linux structure, which has a circular definition with the
// pci_bus structure.
// The compiler has no problem digesting the structure itself, but
// when it comes to declaring an instance of it, it balks.
// Thus, we will declare an instance of an identical structure,
// and we will cast accordingly.
// For Kernel 2.4, we are able to use the pci_dev identifier directly.

#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,4,0)
#define exc_pci_dev pci_dev
#else
struct exc_pci_dev {
	struct pci_bus	*bus;		/* bus this device is on */
	struct pci_dev	*sibling;	/* next device on this bus */
	struct pci_dev	*next;		/* chain of all devices */

	void		*sysdata;	/* hook for sys-specific extension */
	struct proc_dir_entry *procent;	/* device entry in /proc/bus/pci */

	unsigned int	devfn;		/* encoded device & function index */
	unsigned short	vendor;
	unsigned short	device;
	unsigned int	class;		/* 3 bytes: (base,sub,prog-if) */
	unsigned int	hdr_type;	/* PCI header type */
	unsigned int	master : 1;	/* set if device is master capable */
	/*
	 * In theory, the irq level can be read from configuration
	 * space and all would be fine.  However, old PCI chips don't
	 * support these registers and return 0 instead.  For example,
	 * the Vision864-P rev 0 chip can uses INTA, but returns 0 in
	 * the interrupt line and pin registers.  pci_init()
	 * initializes this field with the value at PCI_INTERRUPT_LINE
	 * and it is the job of pcibios_fixup() to change it if
	 * necessary.  The field must not be 0 unless the device
	 * cannot generate interrupts at all.
	 */
	unsigned int	irq;		/* irq generated by this device */

	/* Base registers for this device, can be adjusted by
	 * pcibios_fixup() as necessary.
	 */
	unsigned long	base_address[6];
	unsigned long	rom_address;
};
#endif


///////////////////////////
// Card-specific defines
////////////////////////////

////////////////////////////
// PCMCIA
///////////////////////////
// Cofiguration Register (3rd byte of config reg space)
#define EXC_PCMCIA_CFG_INT_OFFSET		0x2

/////////////////////
// PCI Card Defines
/////////////////////

#define EXC_PCI_VENDOR_ID        0x1405

#define EXC_PCI_PCIPX_DEVICEID_START 0x1002
#define EXC_PCI_PCIPX_DEVICEID_STOP  0x1004
#define EXC_PCI_PCIPX_REVC_DEVICEID_START 0x1102
#define EXC_PCI_PCIPX_REVC_DEVICEID_STOP  0x1104

#define EXC_PCI_429PCI_DEVICEID_START     0x2000
#define EXC_PCI_429PCI_DEVICEID_STOP      0x2003

#define EXC_PCI_4000PCI_DEVICEID_START     0x4000
#define EXC_PCI_4000PCI_DEVICEID_STOP      0x401F
#define EXC_PCI_4000PCIe_DEVICEID_START     0xE400
#define EXC_PCI_4000PCIe_DEVICEID_STOP      0xE40F


// Add entries to modinfo
#if LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0)
static struct pci_device_id exc_pci_tbl[] __devinitdata = 
#else
static struct pci_device_id exc_pci_tbl[] __initdata = 
#endif
{
  {EXC_PCI_VENDOR_ID, 0x1002, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x1003, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x1004, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x1102, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x1103, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x1104, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x2000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x2001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x2002, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x2003, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x4000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x4001, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x4002, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x4003, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x4004, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x4005, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x4006, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x4007, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x4008, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x4009, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x400A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x400B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x400C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x400D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x400E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0x400F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE400, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE401, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE402, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE403, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE404, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE405, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE406, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE407, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE408, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE409, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE40A, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE40B, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE40C, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE40D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE40E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {EXC_PCI_VENDOR_ID, 0xE40F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
  {0,0,0,0,0,0,0},   // terminator
};

MODULE_DEVICE_TABLE(pci, exc_pci_tbl);

#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,12,0)
typedef struct wait_queue_entry wait_queue_t;
#endif

// maximum banks in pci config space, as defined by PCI spec
#define EXC_PCI_MAX_BANKS 6

// I/O registers
#define PCI_IO_INTERRUPT_STATUS		0x1c
#define PCI_IO_INTERRUPT_CONTROL	0x38

// Values for Interrupt Control Register
// 0xF00 in lower bits required
// bit 12 enables/disables interrupts
// bit 17 indicates an interrupt, needs to be reset after
#define PCI_IO_INTCTL_ENABLE		0x00001F00
#define PCI_IO_INTCTL_DISABLE		0x00000F00
#define PCI_IO_INTCTL_RESET	       	0x00021F00
#define PCI_IO_INTCTL_INTMASK		0x00020000

// Masks for Interrupt Status Register
#define PCI_IO_INTSTATUS_CH0MASK	0x01000000
#define PCI_IO_INTSTATUS_CH1MASK	0x02000000
#define PCI_IO_INTSTATUS_ANYCHMASK	0x03000000

// Int reset location in memory
// Write anything to this location to reset
#define PCI_MEM_INTERRUPT_RESET		0x00007001
#define PCI_MEM_INTERRUPT_STATUS	0x0000700C

#define	DAS429PCI_INTSTATUS			0x0006
#define	DAS429PCI_INTRESET			0x0004

// PCIPx Rev C defines
#define EXC_PCIPX_CONFIG            4
#define EXC_PCIPX_INTSTATUS         0x40
#define EXC_PCIPX_INTMASK_ANYMOD    0xF


////////////////////
// Legacy devices
////////////////////

#define PCEP_MEM_INTERRUPT_RESET	0x7001
#define PCEP_MEM_CURRENT_BANK		0x7003
#define PCEP_MEM_BANK_SELECT		0x7004
#define PCEP_BOARD_ID				0x3FFE
#define EXC_MCH_REG_INTERRUPT		0x03
#define EXC_MCH_BANK_SELECT			0x02
#define EXC_MCH_START_DPRAM			0x40

#define DAS429MX_INT_STATUS			0x06
#define DAS429MX_INT_RESET			0x04

#define MAGIC_INT_RESET				0x7F82
#define MAGIC_BOARD_ID				0x7F76
#define MAGIC_SELECT_PIGGY			0x7F88
#define MAGIC_SELECT_MAIN			0x7F8A

#define PCHC_INT_RESET				0x3FE1

#define EXC3900_IO_CTL				0x03
#define EXC3900_INT_RESET			0x41
#define EXC3900_INT_RESET_MON		0x52

#define EXC4000PCI_BOARDID              0x0
#define EXC4000PCI_BOARDIDMASK          0xF

#define EXC4000PCI_INTSTATUS            0x4
#define EXC4000PCI_INTRESET             0x6
#define EXC4000PCI_FPGAREV             0x20

#define EXC4000PCI_INTMASK_ANYMOD       	0x1F
#define EXC4000PCI_INTMASK_ANYMOD_EXPANDED       0x1FF
#define EXC4000PCI_MAX_INTERRUPT_BITS		9
#define EXC4000PCI_MAXMODULES           0x8

#define EXC4000PCI_BANK_GLOBAL          0x4
#define EXC4000PCI_BANK_DMA          0x9

#define EXCPCI_BANK_DMA          0x9
#define EXCPCI_DMA0AddrLo			0x0
#define EXCPCI_DMA0AddrHi			0x4
#define EXCPCI_DMA1AddrLo			0x10
#define EXCPCI_DMA1AddrHi			0x14
#define EXCPCI_DMAGlobalBankCardAddr			0x24
#define EXCPCI_DMA0CardAddr			0x40
#define EXCPCI_DMA1CardAddr			0x44
#define EXCPCI_DMA0RepeatCode			0x44
#define EXCPCI_DMA1RepeatCode			0x44
#define EXCPCI_DMA0StartAddr		0xC
#define EXCPCI_DMA1StartAddr		0x1C
/*
#define EXCPCI_DMA0StartMask		0x2
#define EXCPCI_DMA1StartMask		0x2
*/
#define EXCPCI_DMA0StartMask		0x4
#define EXCPCI_DMA1StartMask		0x4
#define EXCPCI_DMA0Length			0x8
#define EXCPCI_DMA1Length			0x18
#define EXCPCI_DMAStatus			0x24
#define EXCPCI_DMAIntReset			0x34
#define EXCPCI_DMAIntStatus			0x34
#define EXCPCI_807DMAIntStatus			0x70
#define EXCPCI_DMAIntMask			0x3
#define EXCPCI_GlobalDMAIntMask			0x300
#define EXCPCI_DMAIntMaskWrite		0x1
#define EXCPCI_DMAIntMaskRead		0x2
#define EXCPCI_GlobalDMAIntMaskWrite		0x100
#define EXCPCI_GlobalDMAIntMaskRead		0x200
#define EXCAFDXPCI_DMABARNum		0x48
#define EXCPCI_ALTERA_DMA_CTRL			0x00
#define EXCPCI_ALTERA_DMA_CTRL2			0x04
#define EXCPCI_ALTERA_DMA_READ_ADDR			0x20
#define EXCPCI_ALTERA_DMA_WRITE_ADDR			0x24
#define EXCPCI_ALTERA_DMA_LENGTH			0x28
#define EXCPCI_ALTERA_DMA_CONTROL_BITS			0x2C

#define EXC4000PCI_PHYSBANK_DPR         0x0
#define EXC4000PCI_PHYSBANK_GLOBAL      0x1
#define EXC4000PCIE_PHYSBANK_GLOBAL      0x2
#define EXC4000PCI_PHYSBANK_DMA		0x4
#define EXC4000PCI_PHYSBANK_GLOBAL_807		0x2
#define EXC4000PCI_PHYSBANK_DMA_807		0x1
//For some reason, Linux gives us the actual PCI BARs,
//while Windows gives us sequential numbers (as above):
#define EXC4000PCI_PHYSBANK_GLOBAL_807_LINUX		0x4
#define EXC4000PCI_PHYSBANK_DMA_807_LINUX		0x2
#define EXC4000PCI_BANK0_OFFSET         0x0
#define EXC4000PCI_BANK1_OFFSET         0x20000
#define EXC4000PCI_BANK2_OFFSET         0x40000
#define EXC4000PCI_BANK3_OFFSET         0x60000
#define EXC4000PCI_BANK4_OFFSET         0x80000
#define EXC4000PCI_BANK5_OFFSET         0xA0000
#define EXC4000PCI_BANK6_OFFSET         0xC0000
#define EXC4000PCI_BANK7_OFFSET         0xE0000
#define EXC4000PCI_BANK_LENGTH          0x20000
#define EXC4000PCI_MEMLENGTH_DPR        0x80000
#define EXC4000PCI_MEMLENGTH_DPR2       0x100000
#define EXC4000PCI_MEMLENGTH_GLOBAL     0x40
#define EXC4000PCI_TOTAL_MEM			0x80000
#define EXC4000PCI_TOTAL_MEM_807		0x4000000
#define EXC4000PCI_TOTAL_MEM_EXPANDED	0x100000
#define EXC4000PCI_TOTAL_MEM_EXTENDED	0x10000000
#define EXC4000PCI_EXT_BANK_LENGTH			(0x8000000 - 0x40000)
#define EXC4000PCI_EXT_BANK0_OFFSET			0x0
#define EXC4000PCI_EXT_BANK1_OFFSET			(0x8000000 - 0x40000)
#define EXC4000PCI_EXT_BANK2_OFFSET			(0x8000000 - 0x20000)
#define EXC4000PCI_EXT_BANK3_OFFSET			0x8000000


//The next 3 defines are not the same as in Windows 
#define EXCAFDXPCI_PHYSBANK_DPR_AFDX			0x4 //This is the new (256MB) BAR so it is the last one
#define EXCAFDXPCI_PHYSBANK_DPR_4000MODS		0x0 //This is for the 4000 modules so it is the first one
#define EXCAFDXPCI_PHYSBANK_GLOBAL_AND_DMA			0x2
#define EXCAFDXPCI_PHYSBANK_DPR_AFDX_BARNUM			0x4 //This is the new (256MB) BAR so it is the last one
#define EXCAFDXPCI_PHYSBANK_DPR_4000MODS_BARNUM		0x0 //This is for the 4000 modules so it is the first one
#define EXCAFDXPCI_PHYSBANK_GLOBAL_AND_DMA_BARNUM			0x2
#define EXCAFDXPCI_TXDPRBANK_LENGTH			0x1000000 //16MB
#define EXCAFDXPCI_RXDPRBANK_LENGTH			0x7000000 //112MB
#define EXCAFDXPCI_DPRBANK_LENGTH			(EXCAFDXPCI_TXDPRBANK_LENGTH+EXCAFDXPCI_RXDPRBANK_LENGTH)//128MB
#define EXCAFDXPCI_GLOBALBANK_LENGTH			0x1000 
#define EXCAFDXPCI_DMABANK_LENGTH			0x1000 
#define EXCAFDXPCI_TOTAL_MEM (2 * EXCAFDXPCI_DPRBANK_LENGTH) + (4 * EXC4000PCI_BANK_LENGTH) //The memory for the two 4000 modules has a size of 512K = 4 modules in the hardware, but only 2 are used
#define EXC_FPGAREV_NONE 0xFFFE

/////////////////////////////
// Defines for deice extension parameters
#define EXC_AUTOIRQ		0xFFFF
#define EXC_OLDTUPLES	1
#define EXC_NO_W2K		2

/////////////////////////////////
// DMA defines
#define EXC_DMA_BUFFER_SIZE   4096




///////////////////////////////////////////////////////////////////////////////
// Device extension structure

typedef struct _EXCALBR_DEVICE_EXTENSION {

  struct exc_pci_dev *dev;
  BOOL   fExists;

  LONG	dwRefCount;

  DWORD         dwPCIInterfaceType;

  // IRQ Queue
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,4,0)
  struct wait_queue *waitQueue;
#else
  wait_queue_head_t waitQueue;
  wait_queue_t      wait;
#endif



  // General resource items
  BOOL		fUsingIO;
  BOOL		fUsingIRQ;

  // Assigned Resources:

  // .. Memory ranges 
  DWORD	        dwPhysicalAddress[MAX_BANKS];
  DWORD		dwMappedAddress[MAX_BANKS];
  DWORD		dwMemLength[MAX_BANKS];
  DWORD		dwTotalDPRAMMemLength;
  BOOL		fBankPresent[MAX_BANKS];
  BYTE		byteBanksPresent;

  // .. IRQ Line
  unsigned int		dwIrqNumber;
  DWORD		hEventToNotifyApp;
  unsigned int		dwTotalInterrupts;
  BYTE		MchIntShadowRegister;
  unsigned int		MchInterruptCount[MAX_BANKS];

  // .. IO Ports
  DWORD	        dwIobase;
  DWORD		dwIOLength;
  DWORD		dwLastIOWriteOffset;
  BYTE		byteLastIOWriteValue;

  // Flags
  BOOL			fHasName;
  BOOL			fDeviceRemoved;
  BOOL			fNotifyApp;
  BOOL			fDpcQueued;
  BOOL			fInsideIsr;
  BOOL			fAllocationWillBeProcessed;
  BOOL			fAllocationHasBeenProcessed;
  BOOL			fAllocateNow;
  BOOL			fReconfiguration;
  BOOL			fAllocateDynamically;
  BOOL			fRegistryDeviceValid;
  BOOL			fLinkedOnOpen;
  BOOL			fConfigFilterCompleted;
  BOOL			fConfigStartCompleted;
  //BOOL			fUsingAutoIRQ;
  BOOL			fPCMCIA_ResourcesAllocated;
  BOOL			f4000ExpandedMem;
  BOOL			fSupportsDMA;
  
  DWORD			dwBusType;
  DWORD			dwBoardType;
  DWORD			dwBoardSubType;
  DWORD			dwSocketNumber;
  DWORD			dwRegistryDevice;
  DWORD			dwFlags;
  DWORD			dwUnexpectedMessage;
  WORD			wFPGARev;
  
  // Card services items
  //Generic_THUNK	CardServThunk;
  WORD			wCardServHandle;
  WORD			wCardServMemHandle[MAX_BANKS];
  BOOL			fCardServHandleValid;
  BOOL			fCardServRegisComplete;
  dma_addr_t		dma_handle;
  void*			cpu_addr;
  struct list_head 	dma_queue;
  spinlock_t		dma_queue_lock;
  spinlock_t		dma_waitqueue_lock;
  wait_queue_head_t 	dma_waitQueue;
  wait_queue_t      	dma_wait;
  struct work_struct 	work_dma;
  unsigned int dma_count;
  unsigned int dma_queue_size;
  unsigned int max_dma_queue_size;
  int endio_calls;
  int startio_calls;
  int dma_interrupt_count;
  int isr_calls;
  int false_interrupts;
  BOOL			fModWakeup[MAX_MODULES];
  
} EXCDEVICE;

typedef struct _EXC_MEMORY_APP {
	DWORD	dwLinearAddress[MAX_BANKS];
	DWORD	PhysMemSection[MAX_BANKS];
} EXC_MEMORY_MAP;

// extra structures for pnp pcmcia
typedef struct tagPCMCIAMem {
	DWORD	dwMemType;
	DWORD	dwCardAddr;
} PCMCIAMem;

// Memory types (for use in above structure)
#define EXC_MEMTYPE_COMMON	(DWORD) 0x08
#define EXC_MEMTYPE_ATTRIB	(DWORD) 0x02

typedef struct tagPCMCIAIrq {
	DWORD	dwFlags;
} PCMCIAIrq;

typedef struct tagPCMCIAControl {
    WORD		Socket;
    WORD		Attributes;
    BYTE		Vcc;
    BYTE		Vpp1;
    BYTE		Vpp2;
    BYTE		IntType;
    DWORD		ConfigBase;
    BYTE		Status;
    BYTE		Pin;
    BYTE		Copy;
    BYTE		ConfigIndex;	    // Option;
    BYTE		Present;
} PCMCIAControl;


typedef struct tagPCMCIARes {
	DWORD	dwFlags;
	WORD	wPCCardID;
} PCMCIARes;


typedef struct tagExcResourceRequests {
	DWORD	dwMemBase[MAX_BANKS];
	DWORD	dwMemLength[MAX_BANKS];
	WORD	wMemHandle[MAX_BANKS];
	DWORD	dwMemBanks;
	BOOL	fUsingIRQ;
	DWORD	dwIrqNumber;
	BOOL	fUsingIO;
	DWORD	pIORange;
	DWORD	lIORangeLength;
} ExcResourceRequests;

typedef struct tagExcWindowPacket {
	DWORD	dwBase;
	DWORD	dwSize;
	WORD	wHandle;
} ExcWindowPacket;

typedef struct tagExcDMAPacket{
	struct list_head list;
	BOOL read;
	BOOL f_completed;
	struct file *filp;
	const char __user *buf;
	size_t count;
	loff_t *ppos;
	unsigned char internal_buf[EXC_DMA_BUFFER_SIZE];
}ExcDMAPacket;

// device types
#define EXC_BOARD_429MX     1
#define EXC_BOARD_429PCIMX  2
#define EXC_BOARD_1553PCIPX 3
#define EXC_BOARD_4000PCI   4
#define EXC_BOARD_4000PCIE   5
#define EXC_BOARD_AFDX	22
#define EXC_BOARD_1394			32
#define EXC_BOARD_4000ETH		64
#define EXC_BOARD_807			807

///////////////////////////
// 1394 defines
#define EXC1394_BANK0_OFFSET		0
#define EXC1394_BANK1_OFFSET		0x200000
#define EXC1394_BANK2_OFFSET		0x400000
#define EXC1394_BANK3_OFFSET		0x600000
#define EXC1394_BANK_LENGTH			0x200000
#define EXC1394_TOTAL_MEM			0x800000

#define EXC1394PCI_PHYSBANK_DPR		0
#define EXC1394PCI_PHYSBANK_GLOBAL	1
#define EXC1394PCI_PHYSBANK_DMA		2
//For some reason, Linux gives us the actual PCI BARs,
//while Windows gives us sequential numbers (as above):
#define EXC1394PCI_PHYSBANK_GLOBAL_LINUX	2
#define EXC1394PCI_PHYSBANK_DMA_LINUX		4

#define EXC1394PCI_INTSTATUS		0x8
#define EXC1394PCI_INTRESET			0xC
#define EXC1394PCI_INTMASK_ANYMOD	0xF

#define EXC1394PCI_INTMASK_MOD0			0x1
#define EXC1394PCI_INTMASK_MOD1			0x2
#define EXC1394PCI_INTMASK_MOD2			0x4
#define EXC1394PCI_INTMASK_TIMER		0x8

// interface types
#define EXC_INTERFACE_AMCC  1
#define EXC_INTERFACE_CORE  2

// bus types
#define EXC_BUS_ISA  1
#define EXC_BUS_PCI  2

#endif // DRIVER_H

